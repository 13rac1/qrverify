## Why Capacity Warnings Matter

QR codes near maximum capacity have **reduced error correction effectiveness**. Here's the issue:[1][2]

When a QR code is at or near 100% capacity for its version, the error correction level determines how much redundancy can be added. A maximum-capacity Version 40 code can only achieve **7% error correction** even at Level L, whereas a smaller code with the same data might support 15-30% correction.[3][4][5][1]

This means near-capacity codes are **more fragile in real-world conditions**:[2]
- Less resilient to print quality issues, scratches, lighting conditions
- Higher scan failure rates on mobile devices[6]
- No safety margin if content slightly changes (adding one character could exceed capacity entirely)

**However**, your verification workflow already catches this: if a near-capacity code fails to decode reliably, verification will fail and trigger retry with higher error correction. The auto-retry mechanism handles the fragility problem automatically.[3]

**Recommendation**: Skip capacity warnings for MVP. The verification + retry logic already ensures robustness without exposing capacity complexity to users. If codes are too fragile, they simply won't verify and users get a clear error.[7]

***

# Product Requirements Document: qr-verify

**Product name:** qr-verify  
**Package:** github.com/[your-org]/qr-verify  
**Version:** v0.1 (MVP)  
**Status:** Draft  
**Date:** 2025-12-30

## Overview

qr-verify is a Golang library that wraps **go-qrcode** (encoding) and **gozxing** (decoding) to provide a verified QR code generation workflow. The library guarantees that every generated QR code image can be successfully decoded back to the original input data.[8][9][7]

## Problem Statement

Existing QR code libraries provide encoding and decoding as separate operations without built-in verification. Developers must manually implement encode/decode/compare workflows, leading to production incidents when QR codes fail to scan correctly.[9][10][11][6]

## Goals

Following Effective Go principles:[12][13]

1. **Simplicity**: Minimal API surface with sensible defaults[12]
2. **Consistency**: Predictable behavior across all operations[13]
3. **Robustness**: Handle edge cases in encoding modes and character sets automatically[7]
4. **Efficiency**: In-memory operations with minimal overhead[13]

## API Design

### Package Structure

```
qr-verify/
├── qrverify/           # Main package
│   ├── encode.go       # Verified encoding functions
│   ├── verify.go       # Verification logic
│   ├── options.go      # Configuration types
│   └── errors.go       # Error types
└── qrverify_test.go    # Tests
```

### Core Functions

Following Effective Go naming conventions - exported functions use clear, descriptive names:

```go
package qrverify

// Encode generates a verified QR code PNG image.
// Returns error if the generated code cannot be decoded back to data.
func Encode(data string, opts *EncodeOptions) ([]byte, error)

// EncodeToFile generates a verified QR code and writes it to filename.
func EncodeToFile(data string, filename string, opts *EncodeOptions) error

// EncodeDetailed returns the verified QR code with metadata about the encoding.
func EncodeDetailed(data string, opts *EncodeOptions) (*Result, error)

// Verify checks that qrImage decodes to expectedData.
func Verify(qrImage []byte, expectedData string, opts *VerifyOptions) error

// MustEncode is like Encode but panics on error (for static initialization).
func MustEncode(data string, opts *EncodeOptions) []byte
```

### Convenience Function

```go
// Quick generates a verified QR code with recommended defaults:
// - Medium recovery level (15% error correction)
// - 256x256 pixels
// - Auto-retry enabled
// - TRY_HARDER decode hint enabled
func Quick(data string) ([]byte, error)
```

### Configuration Types

Following Go convention - zero values are useful defaults:

```go
type EncodeOptions struct {
    // Recovery specifies error correction level.
    // Zero value uses Medium (15% correction).
    Recovery Recovery
    
    // Size is the image dimension in pixels.
    // Zero value uses 256.
    Size int
    
    // DisableRetry prevents automatic retry with higher recovery levels.
    // Zero value (false) enables retry.
    DisableRetry bool
    
    // MaxRetries limits recovery level escalations.
    // Zero value uses 3 (Low → Medium → High → Highest).
    MaxRetries int
    
    // ForegroundColor sets the dark modules color.
    // Zero value uses black.
    ForegroundColor color.Color
    
    // BackgroundColor sets the light modules color.
    // Zero value uses white.
    BackgroundColor color.Color
}

type VerifyOptions struct {
    // DisableTryHarder disables exhaustive gozxing decoding.
    // Zero value (false) enables TRY_HARDER for maximum accuracy.
    DisableTryHarder bool
}

type Recovery int

const (
    RecoveryLow Recovery = iota      // 7% error correction
    RecoveryMedium                   // 15% error correction (default)
    RecoveryHigh                     // 25% error correction
    RecoveryHighest                  // 30% error correction
)

type Result struct {
    Image     []byte   // PNG image bytes
    Original  string   // Input data
    Decoded   string   // Verified decoded result
    Version   int      // QR code version (1-40)
    Recovery  Recovery // Final recovery level used
    Size      int      // Image dimensions in pixels
}
```

### Error Handling

Following Go error conventions - errors are values with context:

```go
// VerificationError indicates decoded data does not match input.
type VerificationError struct {
    Original string
    Decoded  string
    Recovery Recovery
}

func (e *VerificationError) Error() string {
    return fmt.Sprintf("verification failed: decoded %q does not match original %q (recovery: %v)", 
        e.Decoded, e.Original, e.Recovery)
}

// DecodeError indicates the generated image could not be decoded.
type DecodeError struct {
    Recovery Recovery
    Err      error
}

func (e *DecodeError) Error() string {
    return fmt.Sprintf("decode failed with recovery %v: %v", e.Recovery, e.Err)
}

// Unwrap enables errors.Is/As usage.
func (e *DecodeError) Unwrap() error { return e.Err }
```

## Technical Requirements

### Dependencies

- github.com/skip2/go-qrcode - QR code generation[8]
- github.com/makiuchi-d/gozxing - QR code decoding[9]
- Standard library: image, bytes, errors, image/png, image/color

### Implementation Details

**In-memory operations** - no temporary files:[7]
```go
// Encode workflow
pngBytes, _ := qrcode.New(data, recovery).PNG(size)  // go-qrcode in-memory
img, _ := png.Decode(bytes.NewReader(pngBytes))       // bytes → image
decoded, _ := gozxing.Decode(img, hints)              // decode
if decoded != data { return VerificationError }       // verify
```

**Auto-retry logic** - when `DisableRetry == false`:
1. Encode with requested `Recovery` level
2. Decode with `TRY_HARDER` hint enabled[14]
3. Compare `decoded == original` (strict byte equality)
4. On failure, escalate recovery level and retry
5. Return error after `MaxRetries` exhausted

**Verification strictness** - byte-for-byte comparison only:
- No whitespace normalization[15]
- No case folding
- No encoding transformation[11]
- Ensures character encoding and mode selection bugs surface immediately[16]

### Testing Requirements

Following Go testing conventions:[7]

```go
// Example-based tests in qrverify_test.go
func TestEncode(t *testing.T)
func TestEncodeDetailed(t *testing.T)
func TestVerify(t *testing.T)
func TestQuick(t *testing.T)
func TestAutoRetry(t *testing.T)

// Table-driven tests for data types
func TestDataTypes(t *testing.T) // numeric, alphanumeric, UTF-8, emoji, binary

// Edge case tests
func TestEdgeCases(t *testing.T) // empty, single char, max capacity, whitespace

// Error condition tests
func TestErrors(t *testing.T) // oversized data, corrupted image, decode failure

// Benchmark tests
func BenchmarkEncode(b *testing.B)
func BenchmarkVerify(b *testing.B)

// Example tests (appear in godoc)
func ExampleEncode()
func ExampleQuick()
func ExampleEncodeDetailed()
```

### Documentation

Following godoc conventions:

- Package-level doc explaining purpose and basic usage
- Function comments starting with function name
- Examples in `example_test.go` (appear in godoc)
- README with installation, quickstart, and API reference

## Success Criteria

- Zero verified QR codes fail to decode on first scan[6]
- `Encode()` adds <100ms vs direct `qrcode.Encode()` for <500 byte payloads
- Default configuration achieves >99.9% verification success rate
- No temporary file I/O required
- API is self-documenting via godoc

## Non-Goals (MVP)

- Capacity warnings or pre-flight validation
- Timing metrics in results
- Streaming/chunking across multiple codes
- Custom comparison functions
- QR code style customization beyond colors
- Batch operations
- ISO/IEC 18004 table lookups

## Example Usage

```go
// Quickstart - sensible defaults
png, err := qrverify.Quick("https://example.com")
if err != nil {
    log.Fatal(err)
}
os.WriteFile("qr.png", png, 0644)

// Custom options
opts := &qrverify.EncodeOptions{
    Recovery: qrverify.RecoveryHigh,
    Size:     512,
}
png, err = qrverify.Encode("café ☕", opts)

// Detailed result
result, err := qrverify.EncodeDetailed("data", nil)
fmt.Printf("Version %d, Recovery %v\n", result.Version, result.Recovery)

// Verify existing code
err = qrverify.Verify(pngBytes, "expected data", nil)
if err != nil {
    log.Printf("Verification failed: %v", err)
}
```

[1](https://www.qrcode.com/en/about/error_correction.html)
[2](https://qr-stock.com/articles/knowledge/error-correction)
[3](https://www.blissqr.com/posts/qr-code-error-correction/)
[4](https://www.uniqode.com/blog/qr-code/how-much-data-can-qr-code-hold)
[5](https://www.qrcode-tiger.com/qr-code-data-size)
[6](https://www.headspin.io/blog/qr-code-testing)
[7](https://www.qrcode.com/en/about/version.html)
[8](https://github.com/skip2/go-qrcode)
[9](https://pkg.go.dev/github.com/makiuchi-d/gozxing)
[10](https://pkg.go.dev/github.com/skip2/go-qrcode)
[11](https://stackoverflow.com/questions/51516612/choosing-a-character-encoding-for-qr-codes)
[12](https://dzone.com/articles/effective-api-design-5-principles-to-keep-customer)
[13](https://www.jitterbit.com/blog/api-design-principles/)
[14](https://zxing.github.io/zxing/apidocs/com/google/zxing/DecodeHintType.html)
[15](https://stackoverflow.com/questions/66226350/qr-code-generator-problem-with-missing-white-spaces)
[16](https://free-barcode.com/barcode/barcode-types/qr-code-encoding-indicator.asp)
[17](https://qrcodekit.com/news/qr-code-error-correction/)
[18](https://www.vaocherapp.com/blog/whats-the-recommended-error-correction-level-for-printing-qr-code)
[19](https://www.reddit.com/r/qrcode/comments/p4zyae/how_much_of_a_qr_code_would_need_to_be_defaced_to/)
